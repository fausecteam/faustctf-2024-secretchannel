import requests
import base64
import secrets
import re

HOST = "::1"
PORT = 3000


def find_token(msg):
    token, id = re.findall("<p class=\"big\">([^<]*)</p>", msg)
    return id, token


def find_message(msg):
    return re.search("<h1>Secret Message</h1><p>([^<]*)</p>", msg).group(1)


# Create a new token
def create(content, pw):
    return find_token(requests.post(f'http://[{HOST}]:{PORT}/create', data={'content': content, 'type': 'text', 'pw': pw}).text)


# Create another access token with different permissions through a management token
def manage(token, pw, action, newpw):
    return find_token(requests.post(f'http://[{HOST}]:{PORT}/manage', data={'token': token, 'action': action, 'pw': pw, 'newpw': newpw}).text)


def view(token, pw):
    return find_message(requests.post(f'http://[{HOST}]:{PORT}/', data={'token': viewtoken, 'pw': 'foo'}).text)

# ----------------- Exploit ----------------- #


flag = secrets.token_hex(8)
id, token = create(flag, 'foo')

id, viewtoken = manage(token, 'foo', 'read', 'foo')

text = view(viewtoken, 'foo')
assert text == flag, text
print('[+] Can verify original token')


id2, token2 = create('fake_content', 'fake')
id2, viewtoken2 = manage(token2, 'fake', 'read', 'fake')

forged_token = bytearray(base64.b64decode(viewtoken2))
forged_token[6:6+len(id)] = bytearray([ a^b^c for a,b,c in zip(id.encode(), id2.encode(), forged_token[6:6+len(id)]) ])

text = view(base64.b64encode(forged_token), 'fake')
assert text == flag, text
print('[+] Can verify forged token')

malformed_token = bytearray(base64.b64decode(token))
malformed_token[40] ^= 0xaa

assert requests.post(f'http://[{HOST}]:{PORT}/', data={'token': base64.b64encode(malformed_token), 'pw': 'foo'}).status_code == 400
print('[+] Unable to verify malformed token')
